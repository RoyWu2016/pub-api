package version;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * <p>
 * Within the target application: This file is partially generated by the Maven
 * build, using the maven-templating-plugin, which overlays the project build
 * number and build date directly onto the class.
 *
 * <p>
 * All independent services should have the Version class embedded into them and
 * should be able to call the API at any time, serving as a minor health check
 * for the service
 *
 * @author AI IT Team
 */

@Controller
public class Version {
	/**
	 * The logger for this class.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(Version.class);

	private static final String BUILD_DATE = "${timestamp}";
	private static final String BUILD_VERSION = "${project.version}";

//	@Autowired
//	@Qualifier("dataSource")
//	private DataSource dataSource;

	/**
	 * Create a new instance of the Version class.
	 */
	public Version() {
		LOGGER.info("Version started");
	}

	/**
	 * @return this for jax-rs to marshal as the resource representation
	 */
	@ResponseBody
	@RequestMapping(value = { "/base/version" }, method = RequestMethod.GET, consumes = MediaType.ALL_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public Version self() {
		return this;
	}

	/**
	 * @return the buildDate
	 */
	public String getBuildDate() {
		return BUILD_DATE;
	}

	/**
	 * @return the projectVersion
	 */
	public String getBuildVersion() {
		return BUILD_VERSION;
	}

	/**
	 * Use this api to test the database connection.
	@ResponseBody
	@RequestMapping(value = { "/base/db" }, method = RequestMethod.GET, consumes = MediaType.ALL_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public String testDbConnection() {
		final String sql = "select TO_CHAR(sysdate, 'DD-MM-YYYY HH:MI:SS') FROM DUAL";
		Connection conn = null;
		try {
			conn = this.dataSource.getConnection();
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			Object retVal = null;
			if (rs.next()) {
				retVal = rs.getObject(1);
			}
			stmt.close();
			return "Database connected: " + retVal;
		} catch (SQLException e) {
			return "Connection failed: " + e;
		} finally {
			if (conn != null) {
				try {
					conn.close();
				} catch (Exception e) {
					LOGGER.error("Failed to close the DB connection!", e);
				}
			}
		}
	}
	 */
}
